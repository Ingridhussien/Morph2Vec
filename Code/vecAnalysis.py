#!/usr/bin/env python"""Written in Python 3.5.0."""__author__ = "Nick Kloehn"__copyright__ = "Copyright 2017, Nick Kloehn"__credits__ = []__version__ = "1.0"__maintainer__ = "Nick Kloehn"__email__ = "See the author's website"###############################################################################import re,mathfrom os import walkimport numpy as np# location of corpuspPath = ('/Users/pokea/Documents/Work/UofA/Current/Dissertation/Morph2Vec'			'/Morph2Vec/EditedPairs')vPath = ('/Users/pokea/Documents/Work/UofA/Current/Dissertation/Morph2Vec'			'/Glove/glove.6B/glove.6B.200d.txt')oPath = ('/Users/pokea/Documents/Work/UofA/Current/Dissertation/Morph2Vec'			'/Morph2Vec/Analysis')###############################################################################def getCosineSimilarity(vec1,vec2):	"""Get the Cosine Similarity of two Vectors."""	# (d1 ⋅ d2) indicates vector dot product,	dotProduct = getDotProduct(vec1,vec2)	# ||d1|| indicates vector length	vec1Len = getDotProduct(vec1,vec1) * 0.5	# ||d2|| indicates vector length	vec2Len = getDotProduct(vec2,vec2) * 0.5	# cos(d1, d2) = (d1 ⋅ d2) / ||d1|| ||d2|| 	return dotProduct/(vec1Len * vec2Len)def getDotProduct(vec1,vec2):	"""Get the dot product of two vectors. When those two vectors are the same,	it measures their 'length'."""	if len(vec1) == len(vec2):		return sum([vec1[idx] * vec2[idx] for idx in range(len(vec1))])	else:		print("Vectors are not the same size!")		return Nonedef getVecSpecs(wordSet,vecDict):	#Calculate the mean vector."""	mean = np.array([ float(0) for n in range(200)])	N = 0	N2 = 0	for word in wordSet:		try:			mean += np.array([float(n) for n in vecDict[word]])			N += 1		except:			pass	meanVec = mean/N	# Calculate the average cosine similarity from the mean vector for all vectors in a class.	cosSims = []	for word in wordSet:		try:			currentCosSim = getCosineSimilarity(np.array([float(n) for n in vecDict[word]]),meanVec)			cosSims.append(currentCosSim)		except:			pass	AvgCosineSimilarity = (sum(cosSims))/ len(cosSims)	# Calculate the Standard Deviation from Average Cosine Similarity for all Cos Similarities	variance = 0	for cos in cosSims:		variance += np.power((cos - AvgCosineSimilarity), 2)	sD = math.sqrt(variance)	return (AvgCosineSimilarity,sD)def writeResults(oPath,results):	"""Write Results to Out File."""	with open(oPath, 'a') as of:		string = ''		name, derRes, undRes = results		derMean, derSD = derRes		undMean, undSD = undRes		string += name		string += '\t'		string += str(derMean)		string += '\t'		string += str(undMean)		string += '\t'		string += str(derSD)		string += '\t'		string += str(undSD)		string += '\n'		of.write(string)class Affix:	"""Container Object for an Affix: (1) vectors of members,	and (2) underived/derived pairs."""	def __init__(self,name):		self.name = name		self.vecs = dict()		self.morphs = dict()	def addAffix(self,derived,underived):		self.morphs[derived] = underived	def addVec(self,token,vec):		self.vecs[token] = vec	def getvDict(self):		return self.vecs	def getpDict(self):		return self.morphs	def getName(self):		return self.nameclass Analyze:	def __init__(self,A):		self.A = A		self.ders = set([k for k,v in self.A.getpDict().items()])		self.unds = set([v for k,v in self.A.getpDict().items()])		self.vecs = self.A.getvDict() 	def vectors(self):		derRes = getVecSpecs(self.ders,self.vecs)		undRes = getVecSpecs(self.unds,self.vecs)		return (self.A.getName(),derRes,undRes)class Corpus:	"""Corpus Object takes underived/derived pairs and compares	them to their word vectors."""	def __init__(self,vPath,pPath,oPath):		self.pPath = pPath		self.vPath = vPath		self.oPath = oPath		self.pFs = set()		self.vocab = set()		self.vecDict = dict()	def analyzeVecs(self):		"""Go through each affix class and analyze the vectors."""		for f in self.pFs:			# Declare Affix Object			A = Affix(f[1])			#Open File			with open(f[0], encoding="ISO-8859-1") as infile:				for line in infile:					d,u = re.split('\t',line.strip())					A.addAffix(d,u)					try:						A.addVec(u,self.vecDict[u])						A.addVec(d,self.vecDict[d])					except:						continue			writeResults(self.oPath,Analyze(A).vectors())	def getFiles(self):		"""Get the file names containing all the edited word pairs"""		for (dirpath, dirnames, fs) in walk(self.pPath):			# Got through each edited pair file			for f in fs:				if f != '.DS_Store':					info = (dirpath + '/' + f,f)					self.pFs.add(info)	def getVocab(self):		"""Get the unique set of words found in all pairs."""		for f in self.pFs:			with open(f[0], encoding="ISO-8859-1") as infile:				for line in infile:					d,u = re.split('\t',line.strip())					self.vocab.add(d)					self.vocab.add(u)	def readVecs(self):		"""Extract the word vectors of the words in our vocab from glove."""		with open(self.vPath, encoding="ISO-8859-1") as infile:			for line in infile:				vecData = line.split()				word = vecData[0]				if word in self.vocab:					self.vecDict[word] = vecData[1:]def main():	"""Main function to call the project."""	test = Corpus(vPath,pPath,oPath)	test.getFiles()	test.getVocab()	test.readVecs()	test.analyzeVecs()if __name__ == '__main__':    main()